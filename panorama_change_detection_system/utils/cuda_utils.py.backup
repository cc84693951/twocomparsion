#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CUDA工具函数
提供CUDA加速的图像处理操作和内存管理
"""

import numpy as np
import cv2
import logging
from typing import Optional, Tuple, Union, Any
from functools import wraps

# CUDA支持检测
try:
    import cupy as cp
    CUDA_AVAILABLE = True
    logging.info("CuPy已加载，CUDA加速可用")
except ImportError:
    CUDA_AVAILABLE = False
    logging.warning("CuPy未安装，将使用CPU处理")
    # 创建CuPy的替代实现
    class cp:
        @staticmethod
        def array(x): return np.array(x)
        @staticmethod
        def asnumpy(x): return np.array(x)
        @staticmethod
        def asarray(x): return np.array(x)
        @staticmethod
        def zeros_like(x): return np.zeros_like(x)
        @staticmethod
        def zeros(shape, dtype=None): return np.zeros(shape, dtype=dtype)
        @staticmethod
        def ones_like(x): return np.ones_like(x)
        @staticmethod
        def sqrt(x): return np.sqrt(x)
        @staticmethod
        def sin(x): return np.sin(x)
        @staticmethod
        def cos(x): return np.cos(x)
        @staticmethod
        def arctan2(x, y): return np.arctan2(x, y)
        @staticmethod
        def arccos(x): return np.arccos(x)
        @staticmethod
        def meshgrid(*args, **kwargs): return np.meshgrid(*args, **kwargs)
        @staticmethod
        def arange(*args, **kwargs): return np.arange(*args, **kwargs)
        @staticmethod
        def stack(*args, **kwargs): return np.stack(*args, **kwargs)
        @staticmethod
        def abs(x): return np.abs(x)
        @staticmethod
        def any(x): return np.any(x)
        @staticmethod
        def floor(x): return np.floor(x)
        @staticmethod
        def clip(x, a_min, a_max): return np.clip(x, a_min, a_max)
        @staticmethod
        def where(condition, x, y): return np.where(condition, x, y)
        @staticmethod
        def sum(x, axis=None): return np.sum(x, axis=axis)
        @staticmethod
        def mean(x, axis=None): return np.mean(x, axis=axis)
        @staticmethod
        def std(x, axis=None): return np.std(x, axis=axis)
        @staticmethod
        def logical_and(x, y): return np.logical_and(x, y)
        @staticmethod
        def logical_or(x, y): return np.logical_or(x, y)
        @staticmethod
        def maximum(x, y): return np.maximum(x, y)
        @staticmethod
        def minimum(x, y): return np.minimum(x, y)
        @staticmethod
        def exp(x): return np.exp(x)
        @staticmethod
        def log(x): return np.log(x)
        @staticmethod
        def power(x, y): return np.power(x, y)
        pi = np.pi
        uint8 = np.uint8
        float32 = np.float32
        int32 = np.int32


def ensure_cuda_available(func):
    """装饰器：确保CUDA可用，否则使用CPU版本"""
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        # 检查对象的CUDA状态
        use_cuda = getattr(self, 'use_cuda', None)
        if use_cuda is None:
            # 如果对象没有use_cuda属性，检查cuda_utils
            if hasattr(self, 'cuda_utils'):
                use_cuda = self.cuda_utils.use_cuda
            else:
                use_cuda = False
        
        if not use_cuda or not CUDA_AVAILABLE:
            # 如果有对应的CPU版本方法，调用它
            cpu_method_name = func.__name__.replace('_cuda', '_cpu')
            if hasattr(self, cpu_method_name):
                cpu_method = getattr(self, cpu_method_name)
                return cpu_method(*args, **kwargs)
            else:
                # 没有CPU版本，强制使用CPU处理
                if hasattr(self, 'use_cuda'):
                    old_use_cuda = self.use_cuda
                    self.use_cuda = False
                    try:
                        result = func(self, *args, **kwargs)
                    finally:
                        self.use_cuda = old_use_cuda
                elif hasattr(self, 'cuda_utils'):
                    old_use_cuda = self.cuda_utils.use_cuda
                    self.cuda_utils.use_cuda = False
                    try:
                        result = func(self, *args, **kwargs)
                    finally:
                        self.cuda_utils.use_cuda = old_use_cuda
                else:
                    result = func(self, *args, **kwargs)
                return result
        return func(self, *args, **kwargs)
    return wrapper


class CUDAUtils:
    """CUDA工具类"""
    
    def __init__(self, use_cuda: bool = True, device_id: int = 0):
        self.use_cuda = use_cuda and CUDA_AVAILABLE
        self.device_id = device_id
        
        if self.use_cuda:
            try:
                cp.cuda.Device(device_id).use()
                self.device = cp.cuda.Device(device_id)
                logging.info(f"CUDA设备 {device_id} 已激活")
            except Exception as e:
                logging.warning(f"CUDA初始化失败: {e}, 将使用CPU")
                self.use_cuda = False
    
    def cleanup_memory(self):
        """清理GPU内存"""
        if self.use_cuda:
            try:
                cp.get_default_memory_pool().free_all_blocks()
            except Exception as e:
                logging.warning(f"GPU内存清理失败: {e}")
    
    def to_gpu(self, array: np.ndarray) -> Union[np.ndarray, Any]:
        """将numpy数组转换到GPU"""
        if self.use_cuda:
            return cp.asarray(array)
        return array
    
    def to_cpu(self, array: Union[np.ndarray, Any]) -> np.ndarray:
        """将数组转换到CPU"""
        if self.use_cuda and CUDA_AVAILABLE:
            # 检查是否是CuPy数组
            if hasattr(array, 'get'):  # CuPy数组有get()方法
                return array.get()
            elif hasattr(array, '__array_interface__'):
                try:
                    return cp.asnumpy(array)
                except:
                    return np.asarray(array)
        
        # 如果已经是numpy数组，直接返回
        if isinstance(array, np.ndarray):
            return array
        
        # 其他情况，转换为numpy数组
        return np.asarray(array)
    
    @ensure_cuda_available
    def bilateral_filter_cuda(self, image: np.ndarray, d: int, sigma_color: float, 
                             sigma_space: float) -> np.ndarray:
        """CUDA加速的双边滤波"""
        if not self.use_cuda or not CUDA_AVAILABLE:
            return cv2.bilateralFilter(image, d, sigma_color, sigma_space)
        
        try:
            # 使用CuPy的SciPy实现的高斯滤波作为近似替代
            # 双边滤波在GPU上实现复杂，这里使用高斯滤波作为去噪替代
            img_gpu = self.to_gpu(image)
            
            # 使用高斯滤波作为双边滤波的快速近似
            from cupyx.scipy import ndimage
            
            # 计算合适的sigma值
            sigma = min(sigma_color, sigma_space) / 10.0
            if sigma < 0.5:
                sigma = 0.5
            
            # 对每个通道单独处理
            if len(img_gpu.shape) == 3:
                result_gpu = cp.zeros_like(img_gpu)
                for i in range(img_gpu.shape[2]):
                    result_gpu[:, :, i] = ndimage.gaussian_filter(img_gpu[:, :, i], sigma=sigma)
            else:
                                result_gpu = ndimage.gaussian_filter(img_gpu, sigma=sigma)
            
            return self.to_cpu(result_gpu)
            
        except Exception as e:
            logging.warning(f"CUDA双边滤波失败，回退到CPU: {e}")
            return cv2.bilateralFilter(image, d, sigma_color, sigma_space)
        

    
    @ensure_cuda_available
    def gaussian_blur_cuda(self, image: np.ndarray, kernel_size: int, sigma: float = 0) -> np.ndarray:
        """CUDA加速的高斯滤波"""
        if not self.use_cuda or not CUDA_AVAILABLE:
            return cv2.GaussianBlur(image, (kernel_size, kernel_size), sigma)
        
        try:
            from cupyx.scipy import ndimage
            img_gpu = self.to_gpu(image)
            
            # 生成高斯核参数
            if sigma == 0:
                sigma = 0.3 * ((kernel_size - 1) * 0.5 - 1) + 0.8
            
            # 使用CuPy的高斯滤波
            if len(img_gpu.shape) == 3:
                result_gpu = cp.zeros_like(img_gpu)
                for i in range(img_gpu.shape[2]):
                    result_gpu[:, :, i] = ndimage.gaussian_filter(img_gpu[:, :, i], sigma=sigma)
            else:
                result_gpu = ndimage.gaussian_filter(img_gpu, sigma=sigma)
            
            return self.to_cpu(result_gpu)
    
        except Exception as e:
            logging.warning(f"CUDA高斯滤波失败，回退到CPU: {e}")
            return cv2.GaussianBlur(image, (kernel_size, kernel_size), sigma)
    

    
    @ensure_cuda_available
    def clahe_cuda(self, image: np.ndarray, clip_limit: float = 3.0, 
                   grid_size: Tuple[int, int] = (8, 8)) -> np.ndarray:
        """CUDA加速的CLAHE"""
        if not self.use_cuda or not CUDA_AVAILABLE:
            clahe = cv2.createCLAHE(clipLimit=clip_limit, tileGridSize=grid_size)
            if len(image.shape) == 3:
                # 对于彩色图像，转换到LAB空间处理L通道
                lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)
                lab[:, :, 0] = clahe.apply(lab[:, :, 0])
                return cv2.cvtColor(lab, cv2.COLOR_LAB2BGR)
            else:
                return clahe.apply(image)
        
        try:
            # CLAHE在GPU上实现复杂，暂时回退到CPU
            # 这确保了稳定性，同时保持功能完整
            clahe = cv2.createCLAHE(clipLimit=clip_limit, tileGridSize=grid_size)
            if len(image.shape) == 3:
                lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)
                lab[:, :, 0] = clahe.apply(lab[:, :, 0])
                return cv2.cvtColor(lab, cv2.COLOR_LAB2BGR)
            else:
                return clahe.apply(image)
                
        except Exception as e:
            logging.warning(f"CUDA CLAHE失败，回退到CPU: {e}")
            clahe = cv2.createCLAHE(clipLimit=clip_limit, tileGridSize=grid_size)
            if len(image.shape) == 3:
                lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)
                lab[:, :, 0] = clahe.apply(lab[:, :, 0])
                return cv2.cvtColor(lab, cv2.COLOR_LAB2BGR)
            else:
                return clahe.apply(image)
    

    
    @ensure_cuda_available
    def morphology_cuda(self, image: np.ndarray, operation: str, 
                       kernel_size: int, kernel_shape: str = 'ellipse') -> np.ndarray:
        """CUDA加速的形态学操作"""
        if not self.use_cuda or not CUDA_AVAILABLE:
            if kernel_shape == 'ellipse':
                kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (kernel_size, kernel_size))
            elif kernel_shape == 'rect':
                kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (kernel_size, kernel_size))
            else:  # cross
                kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (kernel_size, kernel_size))
            
            if operation == 'open':
                return cv2.morphologyEx(image, cv2.MORPH_OPEN, kernel)
            elif operation == 'close':
                return cv2.morphologyEx(image, cv2.MORPH_CLOSE, kernel)
            elif operation == 'erode':
                return cv2.erode(image, kernel)
            elif operation == 'dilate':
                return cv2.dilate(image, kernel)
            else:
                return image
        
        try:
            from cupyx.scipy import ndimage
            img_gpu = self.to_gpu(image)
            
            # 创建结构元素
            if kernel_shape == 'ellipse':
                # 创建椭圆结构元素
                y, x = cp.ogrid[-kernel_size//2:kernel_size//2+1, -kernel_size//2:kernel_size//2+1]
                kernel = x*x + y*y <= (kernel_size//2)**2
            elif kernel_shape == 'rect':
                kernel = cp.ones((kernel_size, kernel_size), dtype=bool)
            else:  # cross
                kernel = cp.zeros((kernel_size, kernel_size), dtype=bool)
                center = kernel_size // 2
                kernel[center, :] = True
                kernel[:, center] = True
            
            # 执行形态学操作
            if operation == 'erode':
                result_gpu = ndimage.binary_erosion(img_gpu, structure=kernel)
            elif operation == 'dilate':
                result_gpu = ndimage.binary_dilation(img_gpu, structure=kernel)
            elif operation == 'open':
                result_gpu = ndimage.binary_opening(img_gpu, structure=kernel)
            elif operation == 'close':
                result_gpu = ndimage.binary_closing(img_gpu, structure=kernel)
            else:
                result_gpu = img_gpu
            
            # 确保结果是正确的数据类型
            if result_gpu.dtype == bool:
                result_gpu = result_gpu.astype(cp.uint8) * 255
            
        return self.to_cpu(result_gpu)
    
        except Exception as e:
            logging.warning(f"CUDA形态学操作失败，回退到CPU: {e}")
            if kernel_shape == 'ellipse':
                kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (kernel_size, kernel_size))
            elif kernel_shape == 'rect':
                kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (kernel_size, kernel_size))
            else:  # cross
                kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (kernel_size, kernel_size))
            
            if operation == 'open':
                return cv2.morphologyEx(image, cv2.MORPH_OPEN, kernel)
            elif operation == 'close':
                return cv2.morphologyEx(image, cv2.MORPH_CLOSE, kernel)
            elif operation == 'erode':
                return cv2.erode(image, kernel)
            elif operation == 'dilate':
                return cv2.dilate(image, kernel)
            else:
                return image
    

    
    @ensure_cuda_available
    def threshold_cuda(self, image: np.ndarray, threshold: float, 
                      method: str = 'binary') -> Tuple[np.ndarray, float]:
        """CUDA加速的阈值处理"""
        if not self.use_cuda:
            if method == 'binary':
                _, result = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)
                return result, threshold
            elif method == 'otsu':
                threshold, result = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
                return result, threshold
            else:
                return image, threshold
        
        img_gpu = self.to_gpu(image)
        
        if method == 'otsu':
            threshold = self._otsu_threshold_cuda(img_gpu)
        
        if method in ['binary', 'otsu']:
            result_gpu = cp.where(img_gpu > threshold, 255, 0).astype(cp.uint8)
        else:
            result_gpu = img_gpu
        
        return self.to_cpu(result_gpu), float(threshold)
    
    def _otsu_threshold_cuda(self, image):
        """CUDA版本的Otsu阈值计算"""
        # 计算直方图
        hist, _ = cp.histogram(image, bins=256, range=(0, 256))
        hist = hist.astype(cp.float32)
        
        # 归一化直方图
        total_pixels = cp.sum(hist)
        hist_norm = hist / total_pixels
        
        # 计算最优阈值
        max_variance = 0
        optimal_threshold = 0
        
        for t in range(256):
            # 计算类间方差
            w0 = cp.sum(hist_norm[:t])
            w1 = cp.sum(hist_norm[t:])
            
            if w0 == 0 or w1 == 0:
                continue
            
            mu0 = cp.sum(cp.arange(t) * hist_norm[:t]) / w0
            mu1 = cp.sum(cp.arange(t, 256) * hist_norm[t:]) / w1
            
            variance = w0 * w1 * (mu0 - mu1) ** 2
            
            if variance > max_variance:
                max_variance = variance
                optimal_threshold = t
        
        return optimal_threshold
    
    def get_memory_info(self) -> dict:
        """获取GPU内存信息"""
        if not self.use_cuda:
            return {"available": False, "message": "CUDA不可用"}
        
        try:
            mempool = cp.get_default_memory_pool()
            return {
                "available": True,
                "used_bytes": mempool.used_bytes(),
                "total_bytes": mempool.total_bytes(),
                "device_id": self.device_id
            }
        except Exception as e:
            return {"available": False, "error": str(e)}


def load_image_with_chinese_path(path):
    """
    加载包含中文路径的图像
    """
    try:
        img_array = np.fromfile(path, dtype=np.uint8)
        img = cv2.imdecode(img_array, cv2.IMREAD_COLOR)
        if img is None:
            raise ValueError(f"无法读取图像: {path}")
        return img
    except Exception as e:
        logging.error(f"读取图像失败 {path}: {str(e)}")
        return None


def cuda_bilinear_sample(img_gpu, u_coords, v_coords, valid_mask, output_shape):
    """
    CUDA双线性插值采样
    Args:
        img_gpu (cp.ndarray): 输入图像 (GPU)
        u_coords (cp.ndarray): 采样点的u坐标 (GPU)
        v_coords (cp.ndarray): 采样点的v坐标 (GPU)
        valid_mask (cp.ndarray): 有效采样点的掩码 (GPU)
        output_shape (tuple): 输出图像的形状 (H, W)
    Returns:
        cp.ndarray: 采样后的图像 (GPU)
    """
    if not CUDA_AVAILABLE:
        raise RuntimeError("CUDA is not available. Cannot use cuda_bilinear_sample.")

    height, width = img_gpu.shape[:2]
    output_img_gpu = cp.zeros(output_shape + (3,), dtype=cp.uint8)

    # 获取有效点的索引
    valid_rows, valid_cols = cp.where(valid_mask)
    if len(valid_rows) == 0:
        return output_img_gpu

    # 提取有效点的坐标
    u_valid = u_coords[valid_mask]
    v_valid = v_coords[valid_mask]

    # 获取整数和小数部分
    u_int = cp.floor(u_valid).astype(cp.int32)
    v_int = cp.floor(v_valid).astype(cp.int32)
    u_frac = u_valid - u_int
    v_frac = v_valid - v_int

    # 确保索引在边界内
    u_int = cp.clip(u_int, 0, width - 2)
    v_int = cp.clip(v_int, 0, height - 2)

    # 双线性插值
    for c in range(3):  # BGR通道
        p00 = img_gpu[v_int, u_int, c]
        p01 = img_gpu[v_int, u_int + 1, c]
        p10 = img_gpu[v_int + 1, u_int, c]
        p11 = img_gpu[v_int + 1, u_int + 1, c]

        interpolated = (p00 * (1 - u_frac) * (1 - v_frac) +
                        p01 * u_frac * (1 - v_frac) +
                        p10 * (1 - u_frac) * v_frac +
                        p11 * u_frac * v_frac)

        output_img_gpu[valid_rows, valid_cols, c] = interpolated.astype(cp.uint8)

    return output_img_gpu
